# pylint: disable=line-too-long
"""
Day 14: Disk Defragmentation

Part 1: Given your actual key string, how many squares are used?
Answer: 8216

Part 2: How many regions are present given your key string?
Answer: 1139
"""

from typing import List
from utils import profiler


def get_input(file_path: str) -> str:
    """
    Reads the input file and returns the key string.

    Args:
        file_path (str): Path to the input text file.

    Returns:
        str: The key string.
    """
    with open(file_path, "r", encoding="utf-8") as file:
        return file.readline().strip()


def knot_hash(input_str: str) -> str:
    """
    Computes the Knot Hash for the input string.

    Args:
        input_str (str): Input string.

    Returns:
        str: 32-character hexadecimal Knot Hash.
    """
    lengths = [ord(c) for c in input_str] + [17, 31, 73, 47, 23]
    numbers = list(range(256))
    pos = skip = 0
    for _ in range(64):
        for length in lengths:
            if length > len(numbers):
                continue
            indices = [(pos + i) % len(numbers) for i in range(length)]
            vals = [numbers[i] for i in indices][::-1]
            for i, v in zip(indices, vals):
                numbers[i] = v
            pos = (pos + length + skip) % len(numbers)
            skip += 1
    dense = []
    for i in range(0, 256, 16):
        x = 0
        for n in numbers[i:i+16]:
            x ^= n
        dense.append(x)
    return ''.join(f"{x:02x}" for x in dense)


def hex_to_bin(hex_str: str) -> str:
    """
    Converts hex string to binary string of length 128.

    Args:
        hex_str (str): Hexadecimal string.

    Returns:
        str: Binary string.
    """
    return bin(int(hex_str, 16))[2:].zfill(128)


def neighbors(r: int, c: int, rows: int, cols: int) -> List[tuple]:
    """
    Returns neighbors (up/down/left/right) within grid bounds.

    Args:
        r (int): Row index.
        c (int): Column index.
        rows (int): Total rows.
        cols (int): Total columns.

    Returns:
        List[tuple]: List of neighbor coordinates.
    """
    nbrs = []
    if r > 0:
        nbrs.append((r-1, c))
    if r < rows-1:
        nbrs.append((r+1, c))
    if c > 0:
        nbrs.append((r, c-1))
    if c < cols-1:
        nbrs.append((r, c+1))
    return nbrs


def flood_fill(grid: List[List[int]], r: int, c: int) -> None:
    """
    Marks all connected '1's starting from (r,c) as visited (set to 0).

    Args:
        grid (List[List[int]]): The grid.
        r (int): Row index.
        c (int): Column index.
    """
    stack = [(r, c)]
    rows, cols = len(grid), len(grid[0])
    while stack:
        rr, cc = stack.pop()
        if grid[rr][cc] == 1:
            grid[rr][cc] = 0
            for nr, nc in neighbors(rr, cc, rows, cols):
                if grid[nr][nc] == 1:
                    stack.append((nr, nc))


@profiler
def part_one(key: str) -> int:
    """
    Counts total used squares in 128x128 grid generated by knot hashes.

    Args:
        key (str): Input key string.

    Returns:
        int: Total count of used squares.
    """
    total_used = 0
    for i in range(128):
        kh = knot_hash(f"{key}-{i}")
        bin_row = hex_to_bin(kh)
        total_used += bin_row.count('1')
    return total_used


@profiler
def part_two(key: str) -> int:
    """
    Counts distinct regions of adjacent used squares in the grid.

    Args:
        key (str): Input key string.

    Returns:
        int: Number of regions.
    """
    grid = []
    for i in range(128):
        kh = knot_hash(f"{key}-{i}")
        bin_row = hex_to_bin(kh)
        grid.append([1 if ch == '1' else 0 for ch in bin_row])

    regions = 0
    for r in range(128):
        for c in range(128):
            if grid[r][c] == 1:
                flood_fill(grid, r, c)
                regions += 1
    return regions


if __name__ == "__main__":
    input_key = get_input("inputs/14_input.txt")

    print(f"Part 1: {part_one(input_key)}")
    print(f"Part 2: {part_two(input_key)}")
